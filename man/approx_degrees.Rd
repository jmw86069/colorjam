% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/colorjam-angles.R
\name{approx_degrees}
\alias{approx_degrees}
\title{Interpolation for degree angles}
\usage{
approx_degrees(
  h1,
  h2,
  h = NULL,
  preset = "custom",
  direction = NULL,
  digits = 10,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{h1}{\code{numeric} vector of degree angles, which should
represent the "degree angles from".}

\item{h2}{\code{numeric} vector of degree angles, which should
represent the "degree angles to".}

\item{h}{\code{numeric} or \code{NULL}, where a \code{numeric} vector is a
vector of degree angles "from" that should be converted to
the corresponding interpolated angle "to", When \verb{h is NULL}
then the object returned is a \code{function} to be called
to convert a numeric vector "from" to degree angles "to".}

\item{direction}{\code{integer} or default NULL, which detects the direction
using the input data.
The direction represents whether h1 and h2 are both increasiing together,
which is \code{direction=1}.
When h1 is increasing by h2 is decreasing, \code{direction=-1}.}

\item{digits}{\code{integer} value indicating the number of digits
of precision to use for the input \code{h1} and \code{h2} degree angles,
used when confining to 360 degrees with \code{h1 \%\% 360}, and
this step sometimes produces slight variations for equivalent
values. For example \code{((12.2 \%\% 360) == (372.2 \%\% 360))} is not
\code{TRUE} without rounding to \code{13} or fewer digits.}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{...}{additional arguments are ignored.}
}
\description{
Interpolation for degree angles
}
\details{
This function is analogous to \code{stats::approx()} except for
the special case of degree angles. In this case, degrees
are confined to the range \verb{[0, 360]}, and angle are smoothly
interpolated around the degrees of a circle.

This function should work properly even when the degree angles
in \code{h2} are reversed, or offset. The only implicit requirement
is that angles in "from" should be mapped to one and only one
angle in "to".
}
\examples{
h_colors <- jamba::getColorRamp(c("white", "firebrick"), n=35, trimRamp=c(1, 0));

h1 <- c(12.2, 27.3, 47.0, 66.5, 85.9, 106.3, 131.7,
   223.1, 263.2, 277.2, 307.7, 345.3, 372.2)
h2 <- seq(from=0, to=360, length.out=13)
h_from <- seq(from=0, to=360, length.out=36)[-36]
h_to <- approx_degrees(h1, h2, h_from)
withr::with_par(list("mfrow"=c(2, 2)), {
display_degrees(h_from, col=h_colors)
display_degrees(h_to, col=h_colors)
plot(h1, h2, pch=20, col="#55555555", type="l",
   main="Input h1,h2")
points(h1, h2, pch=20, col=h_colors)
plot(h_from, h_to, pch=20, col="#55555555", type="l",
   main="Output approx_degrees()")
points(h_from, h_to, pch=20, col=h_colors)
})

h1 <- c(12.2, 27.3, 47.0, 66.5, 85.9, 106.3, 131.7,
   223.1, 263.2, 277.2, 307.7, 345.3, 372.2)
h2 <- rev((seq(from=0, to=360, length.out=13))[c(9:12,1:9)])
h_from <- seq(from=0, to=360, length.out=36)[-36]
h_to <- approx_degrees(h1, h2, h_from, direction=-1)
h_to <- approx_degrees(h1, h2, h_from)
withr::with_par(list("mfrow"=c(2, 2)), {
display_degrees(h_from, col=h_colors)
display_degrees(h_to, col=h_colors)
plot(h1, h2, pch=20, col="#55555555", type="l",
   main="Input h1,h2")
points(h1, h2, pch=20, col=h_colors)
plot(h_from, h_to, pch=20, col="#55555555", type="l",
   main="Output approx_degrees()")
points(h_from, h_to, pch=20, col=h_colors)
})

# apply no transform
approx_degrees(h1=0, h2=0, h=c(0, 90, 180, 270))

# apply 180 degree transform
approx_degrees(h1=0, h2=180, h=c(0, 90, 180, 270))
approx_degrees(h1=180, h2=0, h=c(0, 90, 180, 270))

# flip the direction
approx_degrees(h1=c(1, 360), h2=c(359, 0),
   h=c(0, 90, 180, 270))
approx_degrees(h1=c(1, 360), h2=c(359, 0)+90,
   h=c(0, 90, 180, 270))
approx_degrees(h1=c(1, 360)+90, h2=c(359, 0),
   h=c(0, 90, 180, 270))

# verify reverse h2 with break across 0-360
seq1 <- seq(from=0, to=330, by=30)
seq2 <- (rev(seq1) + 120) \%\% 360
seq_out <- seq(from=0, to=350, by=10);
approx_out <- approx_degrees(h1=seq1, h2=seq2, h=seq_out)
plot(seq1, seq2, pch=20, col="blue", asp=1, ylim=c(0, 360))
points(seq_out, approx_out, col="red", cex=2)

# verify forward h2 with break across 0-360
seq1 <- seq(from=0, to=330, by=30)
seq2 <- (seq1 + 120) \%\% 360
seq_out <- seq(from=0, to=350, by=10);
approx_out <- approx_degrees(h1=seq1, h2=seq2, h=seq_out)
plot(seq1, seq2, pch=20, col="blue", asp=1, ylim=c(0, 360))
points(seq_out, approx_out, col="red", cex=2)

}
\seealso{
Other colorjam hue warp: 
\code{\link{add_colorjam_preset}()},
\code{\link{add_colorjam_step}()},
\code{\link{adjust_hue_warp}()},
\code{\link{colorjam_presets}()},
\code{\link{colorjam_steps}()},
\code{\link{display_degrees}()},
\code{\link{h2hw}()},
\code{\link{h2hwOptions}()},
\code{\link{hcl_to_hsl_hue}()},
\code{\link{hsl_to_hcl_hue}()},
\code{\link{hw2h}()},
\code{\link{mean_angle}()},
\code{\link{plot_colorjam_preset}()},
\code{\link{plot_colorjam_steps}()},
\code{\link{remap_colorjam_preset}()},
\code{\link{validate_colorjam_preset}()}
}
\concept{colorjam hue warp}
