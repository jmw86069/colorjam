% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/colorjam-angles.R
\name{approx_degrees}
\alias{approx_degrees}
\title{Interpolation for degree angles}
\usage{
approx_degrees(h1, h2, h = NULL, digits = 5, ...)
}
\arguments{
\item{h1}{\code{numeric} vector of degree angles, which should
represent the "degree angles from".}

\item{h2}{\code{numeric} vector of degree angles, which should
represent the "degree angles to".}

\item{h}{\code{numeric} or \code{NULL}, where a \code{numeric} vector is a
vector of degree angles "from" that should be converted to
the corresponding interpolated angle "to", When \verb{h is NULL}
then the object returned is a \code{function} to be called
to convert a numeric vector "from" to degree angles "to".}

\item{digits}{\code{integer} value indicating the number of digits
of precision to use for the input \code{h1} and \code{h2} degree angles,
used when confining to 360 degrees with \code{h1 \%\% 360}, and
this step sometimes produces slight variations for equivalent
values. For example \code{((12.2 \%\% 360) == (372.2 \%\% 360))} is not
\code{TRUE} without rounding to \code{13} or fewer digits.}

\item{...}{additional arguments are ignored.}
}
\description{
Interpolation for degree angles
}
\details{
This function is analogous to \code{stats::approx()} except for
the special case of degree angles. In this case, degrees
are confined to the range \verb{[0, 360]}, and angle are smoothly
interpolated around the degrees of a circle.

This function should work properly even when the degree angles
in \code{h2} are reversed, or offset. The only implicit requirement
is that angles in "from" should be mapped to one and only one
angle in "to".
}
\examples{
h_colors <- jamba::getColorRamp(c("white", "firebrick"), n=35, trimRamp=c(1, 0));

h1 <- c(12.2, 27.3, 47.0, 66.5, 85.9, 106.3, 131.7,
   223.1, 263.2, 277.2, 307.7, 345.3, 372.2)
h2 <- seq(from=0, to=360, length.out=13)
h_from <- seq(from=0, to=360, length.out=36)[-36]
h_to <- approx_degrees(h1, h2, h_from)
par("mfrow"=c(2, 2))
display_degrees(h_from, col=h_colors)
display_degrees(h_to, col=h_colors)
plot(h_from, h_to, pch=20, col=h_colors)

h2 <- c(12.2, 27.3, 47.0, 66.5, 85.9, 106.3, 131.7,
   223.1, 263.2, 277.2, 307.7, 345.3, 372.2)
h1 <- seq(from=0, to=360, length.out=13)
h_from <- seq(from=0, to=360, length.out=36)[-36]
h_to2 <- approx_degrees(h2, h1, h_from)
par("mfrow"=c(2, 2))
display_degrees(h_from, col=h_colors)
display_degrees(h_to2, col=h_colors)
plot(h_from, h_to2, pch=20, col=h_colors)

h1 <- c(12.2, 27.3, 47.0, 66.5, 85.9, 106.3, 131.7,
   223.1, 263.2, 277.2, 307.7, 345.3, 372.2)
h2 <- rev((seq(from=0, to=360, length.out=13))[c(9:12,1:9)])
h_from <- seq(from=0, to=360, length.out=36)[-36]
h_to <- approx_degrees(h1, h2, h_from)
par("mfrow"=c(2, 2))
display_degrees(h_from, col=h_colors)
display_degrees(h_to, col=h_colors)
plot(h_from, h_to, pch=20, col=h_colors)

# apply no transform
approx_degrees(h1=0, h2=0, h=c(0, 90, 180, 270))

# apply 180 degree transform
approx_degrees(h1=0, h2=180, h=c(0, 90, 180, 270))
approx_degrees(h1=180, h2=0, h=c(0, 90, 180, 270))

# flip the direction
approx_degrees(h1=c(1, 360), h2=c(359, 0), h=c(0, 90, 180, 270))
approx_degrees(h1=c(1, 360), h2=c(359, 0)+90, h=c(0, 90, 180, 270))
approx_degrees(h1=c(1, 360)+90, h2=c(359, 0), h=c(0, 90, 180, 270))

}
\seealso{
Other colorjam hue warp: 
\code{\link{display_degrees}()},
\code{\link{h2hwOptions}()},
\code{\link{h2hw}()},
\code{\link{hw2h}()},
\code{\link{mean_angle}()}
}
\concept{colorjam hue warp}
